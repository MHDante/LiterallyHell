Object subclass: #FormatSpecifier	instanceVariableNames: 'me'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!FormatSpecifier methodsFor: 'initalize-release' stamp: 'ZackHarris 12/20/2015 00:18'!me^me! !!FormatSpecifier methodsFor: 'initalize-release' stamp: 'ZackHarris 12/21/2015 14:00'!printOn: mystream	me		do: [ :a | 			(a isMemberOf: Array)				ifTrue: [ mystream nextPutAll: a ]				ifFalse: [ 					mystream						nextPut: $";						nextPutAll: a;						nextPut: $" ] ]! !!FormatSpecifier methodsFor: 'initalize-release' stamp: 'ZackHarris 10/8/2015 01:36'!init:formatSpec	me :=formatSpec.! !!FormatSpecifier methodsFor: 'initalize-release' stamp: 'ZackHarris 12/17/2015 00:59'!sourceInterval^0 to: 0! !!FormatSpecifier methodsFor: 'initalize-release' stamp: 'ZackHarris 12/17/2015 00:16'!storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $'.	self printOn: aStream.	aStream nextPut: $'.! !TempVariableNode subclass: #TypedTempVariableNode	instanceVariableNames: 'type'	classVariableNames: 'mutable'	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 15:55'!type	^type! !!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 20:12'!printOn: aStream	self type printOn: aStream.	super printOn: aStream.! !!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 15:24'!name:n index: i type:t mutable:bool	type := t.	mutable :=bool.	super name: n index:i type:3 scope:0! !!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:58'!sourceInterval^0 to: 0! !!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 15:55'!mutable	^mutable! !!TypedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 15:23'!name:n index: i type:t	self name: n index:i type:t mutable:False! !MessageNode subclass: #TypedMessageNode	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 17:34'!type	^ type! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:28'!printOn: aStream	self type printOn: aStream.	super printOn: aStream.! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 20:58'!isSuperSend^false! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 17:34'!receiver: rcvr selector: selNode arguments: args precedence: p type: t	"Decompile."	type := t.	self		receiver: rcvr		selector: selNode		arguments: args		precedence: p! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 20:54'!isInlined^false! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 20:55'!isCascaded^false! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 16:56'!name	^self selector asString! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:58'!sourceInterval^0 to: 0! !!TypedMessageNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 09:19'!selector	^ super selector key! !ParseNode subclass: #DefinitionNode	instanceVariableNames: 'type assignment'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!DefinitionNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/17/2015 00:59'!sourceInterval^0 to: 0! !!DefinitionNode methodsFor: 'initialize-release' stamp: 'DanteCamarena 11/10/2015 07:07'!type: t assignment: assmtNode	assignment := assmtNode.	type:=t.! !!DefinitionNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/13/2015 14:39'!variable| vr |vr := assignment variable. ^ TypedVariableNode new name: vr name type: self type! !!DefinitionNode methodsFor: 'accessing' stamp: 'DanteCamarena 11/10/2015 07:06'!type	^ type! !!DefinitionNode methodsFor: 'accessing' stamp: 'DanteCamarena 11/10/2015 07:06'!assignment	^ assignment! !!DefinitionNode methodsFor: 'accessing' stamp: 'DanteCamarena 12/12/2015 14:01'!accept: parser	^assignment accept: parser! !MethodNode subclass: #TypedMethodNode	instanceVariableNames: 'type receiverType compilationContext scope'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:58'!pragmas^#().! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 16:00'!type	^ type! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 19:03'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	self selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim type:(TypeNode new name: 'void' length: 0)! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 00:16'!compilationContext:c 	compilationContext:= c! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 07:22'!primitiveFromPragma^IRPrimitive null.! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/20/2015 07:48'!selector: selOrFalse arguments: args precedence: lolno temporaries: temps block: blk encoder: anEncoder primitive: prim type: t receiverType:recType|prec|	type:= t ifNil: (TypeNode new name: 'void' length: 0).	receiverType := recType.	prec := (args size = 0) ifTrue: [ 1 ] ifFalse: [ 3 ].	super selector: selOrFalse arguments: args precedence: prec temporaries: temps block: blk encoder: anEncoder primitive: prim ! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 16:55'!name	^self selector asString! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 19:05'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim type: t	self selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim type:t receiverType:(TypeNode new name: 'god' length: 0)! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:37'!type: t name: n argumentTypes: argtypes receiverType: receType		|s|s:=self selector: n asSymbol				arguments: (argtypes collect: [ :a | TypedVariableNode new name: 'sarg' type: (TypeNode new name: a length: 0)])				precedence: 1				temporaries:					{  }				block: (TypedBlockNode new						arguments: {}						statements:{}						returns: nil						from: nil)				encoder: nil				primitive: 0				type: (TypeNode new name: t length: 0)				receiverType: (TypeNode new name: receType length: 0).								^s! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:28'!printOn: aStream	"self type printOn: aStream."	super printOn: aStream.! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:58'!sourceInterval^0 to: 0! !!TypedMethodNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 19:02'!receiverType	^ receiverType! !!TypedMethodNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 19:29'!scope	^ scope! !!TypedMethodNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 19:29'!scope: s	scope := s! !!TypedMethodNode methodsFor: 'accessing' stamp: 'DanteCamarena 12/20/2015 07:38'!methodClass	^compilationContext getClass.! !!TypedMethodNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 20:28'!gtInspectorSourceCodeIn:iunno ^'lolno'! !!TypedMethodNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 17:57'!compilationContext	^ compilationContext! !!TypedMethodNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 20:28'!source ^'lolno'! !BlockNode subclass: #TypedBlockNode	instanceVariableNames: 'scope'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 19:35'!scope	^ scope! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 19:35'!scope: s	scope := s! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 21:03'!isInlined^false! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/17/2015 01:33'!accept: aVisitor	(aVisitor isKindOf: OCASTTranslatorForEffect)	ifTrue:[^aVisitor visitSequenceNode: self] ifFalse:[^super accept:aVisitor].! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 21:05'!argumentNames	^arguments collect:[:arg|arg name].! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/17/2015 00:57'!sourceInterval^0 to: 0! !!TypedBlockNode methodsFor: 'accessing' stamp: 'ZackHarris 12/16/2015 21:18'!body	^TBNWrapper new TBN: self.! !!TypedBlockNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 20:05'!lastIsReturn	(statements size = 0) ifTrue: [ ^false ].	^((statements at: (statements size)) isKindOf: ReturnNode).! !VariableNode subclass: #TypedVariableNode	instanceVariableNames: 'type'	classVariableNames: 'mutable'	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedVariableNode commentStamp: 'ZackHarris 11/6/2015 23:40' prior: 0!VariableNode that holds a type. That is what I am.!!TypedVariableNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/17/2015 00:01'!name: n type: t	type := t.	self		name: n		key: n asSymbol		index: nil		type: 3! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/15/2015 20:11'!printOn: aStream	self type printOn: aStream.	super printOn: aStream.! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/12/2015 15:20'!type	^type! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'DanteCamarena 12/21/2015 08:35'!isLiteralVariable	^false! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'DanteCamarena 12/21/2015 08:36'!isUndeclared	^false! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/12/2015 15:20'!mutable	^mutable! !!TypedVariableNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/16/2015 23:59'!name:n type:t mutable:bool	mutable :=bool.	self name: n type:t! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypedVariableNode class	instanceVariableNames: ''!!TypedVariableNode class methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 21:05'!fromNode: varNode typeStr: typ	|tvn|	tvn := self new name: (varNode name) type: (TypeNode new name:typ).	^tvn! !!TypedVariableNode class methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 21:05'!fromNode: varNode type: typ	|tvn|	tvn := self new name: (varNode name) type: typ.	^tvn! !ParseNode subclass: #PELProgram	instanceVariableNames: 'declarations methods initializer class'	classVariableNames: 'counter'	poolDictionaries: ''	category: 'CPS710-Assign2'!!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 12/20/2015 07:06'!compilationClass	^class! !!PELProgram methodsFor: 'accessing' stamp: 'ZackHarris 12/12/2015 17:10'!accept:aVisitor	^aVisitor visitPELProgramNode: self. ! !!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 12/20/2015 04:45'!sourceInterval^0 to: 0! !!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 11/11/2015 07:26'!methods	^ methods! !!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 12/19/2015 21:58'!initializer^initializer! !!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 11/11/2015 07:26'!declarations	^ declarations! !!PELProgram methodsFor: 'accessing' stamp: 'DanteCamarena 12/21/2015 09:47'!superclass: k name: n declarations: a methods: b |init context|counter:= counter + 1.class:= CompilationClass subclass: n, (counter asString).class category: 'CPS710-Test'.context := class compiler compilationContext.methods := b.a size > 0 ifTrue:[init:= 	TypedMethodNode new				selector: #initialize				arguments: { }				precedence: 1				temporaries:{}				block:					(TypedBlockNode new							arguments: {}						statements: (a collect:[:d|d assignment])						returns:false						from:nil						)				encoder: nil				primitive: 0				type: (TypeNode new name:'void'length:0).	methods := {init},b].	declarations := a.	declarations do:[:c| class addInstVarNamed: c variable name		].	methods do:[:e|e compilationContext: context].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PELProgram class	instanceVariableNames: ''!!PELProgram class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 15:25'!init	counter:=0.! !Object subclass: #TBNWrapper	instanceVariableNames: 'tbn'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TBNWrapper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 21:17'!acceptVisitor:visitor	^visitor visitSequenceNode: tbn.! !!TBNWrapper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 21:17'!TBN:ttbn:=t.! !LiteralNode subclass: #TypedLiteralNode	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedLiteralNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 17:48'!type^type! !!TypedLiteralNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 20:12'!printOn: aStream	self type printOn: aStream.	super printOn: aStream.! !!TypedLiteralNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 00:58'!sourceInterval^0 to: 0! !!TypedLiteralNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 09:52'!value(key isKindOf: FormatSpecifier) ifTrue: [ ^ key printString ].	^ key! !!TypedLiteralNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 18:35'!name: literal key: object index: i type: t	type:=t.	^super name: literal key: object index: i type: 3! !PPCompositeParser subclass: #PELParser	instanceVariableNames: 'def proc sig body stmt expr fn type exprlist id print while for assmt return literal if do int real bool string formatChar format var pr'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/17/2015 01:44'!return	^ 'return' asParser trim , expr optional ==> [ :a | TypedReturnNode new expr: (a at:2) ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/20/2015 07:47'!proc	^ (sig trim , body trim , 'corp' asParser)		==> [ :a | 			| s m p |			s := a at: 1.			"p := (s at: 4).			p := ((p = nil) or: [ p size = 0 ]) 				ifTrue: [ p := 1 ]				ifFalse: [ p := 3 ]."							 m :=TypedMethodNode new				selector: (PELParser generateSelector: ((s at: 3) name asSymbol) numArgs: ((s at: 4) size))				arguments: (s at: 4)				precedence: p				temporaries:					(((a at: 2) select: [ :e | e isKindOf: DefinitionNode ])						collect: [ :e | 							| q |							q := e assignment.							(q isKindOf: MessageNode)								ifTrue: [ q := q receiver ]								ifFalse: [ q := q variable ].							TypedTempVariableNode new name: (q name) index: (q index) type: (e type) ]						)				block:					(TypedBlockNode new						arguments: (s at: 4)						statements:							((a at: 2)								collect: [ :e | 									(e isKindOf: DefinitionNode)										ifTrue: [ e assignment ]										ifFalse: [ e ] ])						returns: (s at: 1) isNotNil						from: nil)				encoder: nil				primitive: 0				type: (s at: 1).				m								 ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/16/2015 23:52'!var	^ (id trim, (($[ asParser trim, exprlist , $] asParser trim) / ($( asParser trim, exprlist optional , $) asParser trim)) optional trim)		==> [ :a | 			| b |			b := a at: 2.			b isNil				ifTrue: [ a at: 1 ]				ifFalse: [ 					(b at: 1) = $[						ifTrue: [							TypedMessageNode new								receiver: (a at: 1)								selector: (SelectorNode new key: #at:)								arguments: (b at: 2)								precedence: 2 ]						ifFalse: [ 							|args sel|							args:=((b at: 2) ifNil: { }).							sel:=((a at: 1) key).							TypedMessageNode new        								receiver:									(VariableNode new										name: #self										key: #self										index: nil										type: 3)								selector: (SelectorNode new key: (PELParser generateSelector: sel numArgs: args size))								arguments: args								precedence: 3 ] ] ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/16/2015 22:08'!bool	^ ('true' asParser ==> [ :a | true ]) / ('false' asParser ==> [ :a | false ])! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/17/2015 01:09'!expr	| ex1 ex2 ex3 ex4 ex5 block comps paren negation leaf|	block:= [ :a :op :b | 			TypedMessageNode new				receiver: a				selector: (SelectorNode new key: op asSymbol)				arguments: {b}				precedence: 2 ].				leaf := literal / if / var.		paren := ($( asParser , expr , $) asParser) trim ==> [ :a | a at: 2 ] / leaf.		negation := (($!! asParser , paren)		==> [ :a | 			TypedMessageNode new				receiver: (a at: 2)				selector: (SelectorNode new key: #negate)				arguments: {}				precedence: 1 ]) / paren.	ex5 := (negation separatedBy: $^ asParser trim) foldLeft: block.	ex4 := (ex5 separatedBy: ($* asParser / $/ asParser) trim) foldLeft: block.	ex3 := (ex4 separatedBy: ($+ asParser / $- asParser) trim) foldLeft: block.	comps := '=' asParser / '!!=' asParser / '>=' asParser / '>' asParser / '<=' asParser / '<' asParser.	ex2 := (ex3 separatedBy: comps trim) foldLeft: block.	ex1 := (ex2 separatedBy: $& asParser trim) foldLeft: block.	^ (ex1 separatedBy: $| asParser trim) foldLeft: block! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/7/2015 23:00'!exprlist	^ (expr separatedBy: $, asParser trim) ==> [ :a | a select: [ :each | each ~= $, ] ]! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 12/21/2015 10:43'!id	| p pd |	p := #letter asParser / $$ asParser / $_ asParser.	pd := p / #digit asParser.	^ (p , pd star) flatten		==> [ :v | 			(self keywords includes: v)				ifTrue: [ PPFailure message: 'keyword matched' ]				ifFalse: [ 					VariableNode new						name: v asSymbol						key: v asSymbol						index: nil						type: 3 ] ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/12/2015 20:12'!def	^ (type trim , assmt)		==> [ :a | 			| mn |			mn := a at: 2.			(mn isKindOf: MessageNode)				ifTrue: [ 					"| n result args |					args := mn arguments.					n := args at: 1.					(a at: 1) dimensions: n.					((mn arguments at: 2) isKindOf: LiteralNode)						ifTrue: [ 							result := MessageNode new								receiver: mn receiver								selector: (SelectorNode new key: #fillN:with:)								arguments: mn arguments								precedence: 3 ]						ifFalse: [ result := mn arguments at: 2 ].					DefinitionNode new type: (a at: 1) assignment: (AssignmentNode new variable: mn receiver value: result)" 					(Error subclass: #ImSoFuckingDone) signal: 'The assignment definition was ambiguous' .					]				ifFalse: [ DefinitionNode new type: (a at: 1) assignment: (a at: 2) ] ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 11/5/2015 22:45'!keywords	^ Set newFrom: #(			proc corp			if then else fi			do od			print as			while			for from to by			return			int string real array format bool			true false			mutable static			)! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/11/2015 01:09'!formatChar	^ $~ asParser / $@ asParser / $# asParser / $. asParser / $* asParser / $+ asParser! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/9/2015 13:49'!body	^ stmt trim star optional trim		==> [ :a | 			a isNil				ifFalse: [ a asOrderedCollection ]				ifTrue: [ {} asOrderedCollection ] ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/16/2015 21:20'!do	^ ('do' asParser , body trim , 'od' asParser)		==> [ :a | 			| b |			b := TypedBlockNode new				arguments: {}				statements: (a at: 2)				returns: False				from: nil.			TypedMessageNode new				receiver: b				selector: (SelectorNode new key:#value)				arguments: {}				precedence: 3 ]! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/9/2015 13:57'!type	| array str |	array := ('array' asParser trim , (($[ asParser trim , exprlist , $] asParser) ==> [ :a | a at: 2 ]) optional trim)		==> [ :a | (a at: 2) ifNil: {} ].	str := ('string' asParser trim , (($[ asParser trim , expr , $] asParser) ==> [ :a | a at: 2 ]) optional trim)		==> [ :a | TypeNode new name: (a at: 1) length: (a at: 2) ].	^ (('int' asParser / 'real' asParser / 'bool' asParser / 'format' asParser / str) trim		==> [ :a | TypeNode new name: a ] , array trim optional)		==> [ :a | 			(a at: 2) isNil				ifTrue: [ a at: 1 ]				ifFalse: [ ArrayTypeNode new innerType: (a at: 1) dimensions: (a at: 2) ] ]! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 12/21/2015 10:02'!start	"Answer the production to start this parser with."	^ (proc / def) plus		==> [ :a | 			PELProgram new			superclass: CompilationClass name:'PELClass' declarations: (a select: [ :b | b isKindOf: DefinitionNode ])				methods: (a select: [ :b | b isKindOf: MethodNode ]) ]! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/9/2015 13:40'!stmt	^ print / while / for / assmt / return / expr / def / do! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/21/2015 14:18'!for	^ ('for' asParser trim , id trim		,			(((('from' asParser / ':=' asParser) ==>[:a|true]) trim , expr , 'to' asParser trim , expr , ('by' asParser trim , expr) optional , stmt trim)				/ (stmt trim ==> [ :a | {a} ])))		==> [ :a |			| b |			b := a at: 3.			(b at: 1) = true				ifTrue: [ 					TypedMessageNode new						receiver: (b at: 2)						selector: (SelectorNode new key: #to:by:do:)						arguments:							{(b at: 4).							((b at: 5) isNil ifTrue: [ literal parse:'1' ] ifFalse:[(b at:5)at:2]).							(TypedBlockNode new								arguments: {TypedVariableNode fromNode: (a at: 2) typeStr: 'int'}								statements: {(b at: 6)} asOrderedCollection								returns: False								from: nil)}						precedence: 3 ]				ifFalse: [ 					TypedMessageNode new						receiver: (a at: 2)						selector: (SelectorNode new key: #doWithIndex:)						arguments:							{(TypedBlockNode new								arguments:									{VariableNode new										name: 'item'										key: #item										index: nil										type: 3.										VariableNode new										name: 'index'										key: #index										index: nil										type: 3}								statements: {(b at: 1)} asOrderedCollection								returns: false								from: nil)}						precedence: 3 ] ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/16/2015 22:09'!literal	| f r i b s |	f := format trim		==> [ :a | 			TypedLiteralNode new				name: a				key: a				index: nil				type: (TypeNode new name:'format')].	r := real trim		==> [ :a | 			TypedLiteralNode new				name: a				key: a asFloat				index: nil				type: (TypeNode new name:'real') ].	i := int trim		==> [ :a | 			TypedLiteralNode new				name: a				key: a asInteger				index: nil				type: (TypeNode new name:'int') ].	b := bool trim		==> [ :a | 			TypedLiteralNode new				name: a				key: a				index: nil				type: (TypeNode new name:'bool') ].	s := string trim		==> [ :a | 			TypedLiteralNode new				name: a				key: a				index: nil				type: (TypeNode new name:'string' length:a size) ].	^ r/f / i / b / s! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 12/21/2015 09:20'!assmt	^ (var trim , ':=' asParser trim , expr trim)		==> [ :a | 			| b |			b := a at: 1.			(b isKindOf: MessageNode)				ifFalse: [ AssignmentNode new variable: b value: (a at: 3) ]				ifTrue: [ 					b selector = #at:						ifTrue: [ 							TypedMessageNode new								receiver: b receiver								selector: (SelectorNode new key: #at:put:)								arguments:									{(b arguments at: 1).									(a at:3)}								precedence: 3 ]						ifFalse: [ PPFailure message: 'Assigment To methodResult' ] ] ].! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/7/2015 23:06'!string	| doublequote |	doublequote := $" asParser.	^ (doublequote , ('""' asParser / doublequote negate) star flatten , doublequote) ==> [ :s | s at: 2 ]! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/19/2015 23:40'!format	"| strOrNum formatPieces x y  |	strOrNum := string.	formatPieces := (formatChar / string) star.	x := (strOrNum optional , formatChar , formatPieces)		==> [ :a | 			(a at: 1) isNil				ifTrue: [ {(a at: 2)} , (a at: 3) ]				ifFalse: [ {(a at: 1)} , {(a at: 2)} , (a at: 3) ] ].	y := (strOrNum , strOrNum , formatPieces) ==> [ :a | {(a at: 1)} , {(a at: 2)} , (a at: 3) ].	^(x / y) ==> [ :a | FormatSpecifier new init: a ]."	"|formatChars strFirst specifier|formatChars := formatChar plus.strFirst := string , formatChars.specifier := (strFirst / (formatChars==>[:a|{a}])) , (string / formatChars) star.^specifier ==> [ :a | FormatSpecifier new init: (a at: 1),(a at: 2)]."^FSParser new.! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/17/2015 01:09'!if	| b |	b := 'if' asParser trim , expr trim , 'then' asParser trim , body trim , 'else' asParser trim , body trim		, 'fi' asParser trim.	^ ((b not , ('if' asParser trim , expr trim , 'then' asParser optional trim , body trim))		==> [ :a | 			TypedMessageNode new				receiver: ((a at: 2) at: 2)				selector: (SelectorNode new key: #ifTrue:)				arguments:					{(TypedBlockNode new						arguments: {}						statements: ((a at: 2) at: 4)						returns: True						from: nil)}				precedence: 3 ])		/			(b				==> [ :a | 					TypedMessageNode new						receiver: (a at: 2)						selector: (SelectorNode new key: #ifTrue:ifFalse:)						arguments:							{(TypedBlockNode new								arguments: {}								statements: (a at: 4)								returns: True								from: nil).							(BlockNode new								arguments: {}								statements: (a at: 6)								returns: True								from: nil)}						precedence: 3 ])! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/9/2015 12:28'!pr^$a asParser .! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/17/2015 01:09'!fn	^ (id , $( asParser , exprlist , $) asParser)		==> [ :a | TypedMessageNode new receiver: 'self' selector: (a at: 1) , ':' arguments: (a at: 3) ]! !!PELParser methodsFor: 'grammar' stamp: 'DanteCamarena 11/10/2015 06:47'!sig| params declist dec|	dec:= ('mutable' asParser trim optional , type trim , id trim)		==> [ :a | TypedVariableNode new name: (a at: 3) name type: (a at: 2) mutable: (a at: 1) isNotNil ].	declist:= (dec separatedBy: $, asParser trim) ==> [ :a | a select: [ :each | each ~= $, ] ].	params:= $( asParser trim, declist optional , $) asParser trim ==> [ :a|(a at: 2) ].		^ type optional, 'proc' asParser trim , id trim, (params optional trim ==> [ :a|a ifNil: { } ])! !!PELParser methodsFor: 'grammar' stamp: 'ZackHarris 12/16/2015 22:52'!print	| e1 |	e1 := (expr trim , ('as' asParser trim , expr trim) optional)		==> [ :a | 			(a at: 2) isNil				ifTrue: [ {(a at: 1)} ]				ifFalse: [ 					{(a at: 1).					((a at: 2) at: 2)} ] ].	^ ('print ' asParser trim , e1)		==> [ :a ||m| 			m:=TypedMessageNode new				receiver:					(VariableNode new						name: #self						key: #self						index: nil						type: 3)				selector:					(SelectorNode new						key:							((a at: 2) size = 1								ifTrue: [ #print: ]								ifFalse: [ #print:as: ]))				arguments: (a at: 2)				precedence: 3.				m ]! !!PELParser methodsFor: 'Grammar' stamp: 'DanteCamarena 11/7/2015 23:05'!real	^ ((int , $. asParser , int optional) / (int optional , $. asParser , int)) flatten ==> [ :r | ('0' , r) asNumber ]! !!PELParser methodsFor: 'Grammar' stamp: 'ZackHarris 10/7/2015 19:05'!while	^'while' asParser, expr, stmt.! !!PELParser methodsFor: 'Grammar' stamp: 'DanteCamarena 11/7/2015 23:01'!int	^ #digit asParser plus flatten ==> [ :a | a asInteger ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PELParser class	instanceVariableNames: ''!!PELParser class methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 23:51'!generateSelector: cake numArgs: n	|s|s:=cake asString.	(n = 0) ifTrue: [ ^cake ]."carrot cake =)"	s := cake,':'.	0 to: (n-2) by: 1 do: [:i| s := s,'a',(i asString),':' ].   ^s asSymbol	! !LeafNode subclass: #TypeNode	instanceVariableNames: 'name length'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/15/2015 19:54'!asString	^ name! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/13/2015 15:27'!negated^-3! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/13/2015 16:01'!name:n length:lname:=n.length :=l  ! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/15/2015 19:53'!printString	^ name! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/17/2015 00:59'!sourceInterval^0 to: 0! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/15/2015 22:19'!unify: typeNode	|arr|	arr:= 	{(self name = typeNode name).	 (self name = 'object' and: typeNode name ~= 'void').	 (self name ~= 'void' and: typeNode name = 'object').	 (self name = 'format' and: typeNode name = 'string').	 (self name = 'real' and: typeNode name = 'int').	 (self name = 'void')}.	^arr detect: [:a| a=true] ifFound: [ true ] ifNone: [ false ]! !!TypeNode methodsFor: 'initialize-release' stamp: 'ZackHarris 12/21/2015 14:15'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self name.! !!TypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/7/2015 21:46'!name:nname:=n! !!TypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/7/2015 21:43'!name^name! !TypeNode subclass: #ArrayTypeNode	instanceVariableNames: 'innerType dimensions'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!ArrayTypeNode methodsFor: 'initialize-release' stamp: 'DanteCamarena 11/8/2015 02:24'!innerType: t dimensions: n	innerType := t.	dimensions := n! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/7/2015 21:51'!innerType:t ^innerType :=t! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/8/2015 02:25'!dimensions^dimensions! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 19:26'!dimensions: d	dimensions := d! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/7/2015 21:50'!name^innerType name, ' array'.! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 02:03'!unify: typeNode	^ (super unify: typeNode)		ifFalse: [ 			(innerType unify: typeNode)				ifTrue: [ ^ #derp ]				ifFalse: [ ^ false ] ]		ifTrue: [ ^ true ]! !!ArrayTypeNode methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/7/2015 21:48'!innerType^innerType! !ReturnNode subclass: #TypedReturnNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign2'!!TypedReturnNode methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 01:19'!value	^ expr! !ParseNodeVisitor subclass: #PrintASTAsSmalltalk	instanceVariableNames: 'stream temps tabs'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assignment1'!!PrintASTAsSmalltalk commentStamp: 'DanteCamarena 9/25/2015 07:27' prior: 0!Prints ASTs as SmallTalk for several different situations, using the visitor pattern.The PrintASTAsSmalltalk is a visitor class that implements methods to visit the different types of nodes found within an abstract syntax tree. A visitor object is supplied as an argument to the accept method found on these various nodes, and each node will then call the approapriate method on the visitor object, passing itself as an argument. This allows each node to be handled differently in a flexible way while iterating over nodes in the tree.To use this class, simply instantiate an object, and then call the accept method found on any given node that implements the visitor pattern. Be sure to subclass this class in case that you wish to override or add more methods to handle more nodes.!!PrintASTAsSmalltalk methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 06:19'!nt	tabs := tabs+1. stream crtab:tabs.! !!PrintASTAsSmalltalk methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 06:19'!n	stream crtab:tabs.! !!PrintASTAsSmalltalk methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 06:19'!s	stream space.! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!format:ast	ast accept: self.	^stream contents.	! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!formatString:str	^self formatString:str inClass:Object.! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!formatMethod: method inClass: cl	"formats an arbitrary AST"	| str |	str := (cl methodDict at: method) sourceCode.	^self formatString: str inClass:cl.! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!formatString:str inClass:klass	^self format: (Parser new parse: str class:klass).! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!formatString: str instanceVariables: vars	"formats an arbitrary AST"	| classFactory cl |	classFactory := ClassFactoryForTestCase new. 	cl := classFactory newSubclassOf: Object instanceVariableNames: vars classVariableNames: ''. 	cl class compile: 'initialize 		^self'.	^self formatString: str inClass:cl! !!PrintASTAsSmalltalk methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:19'!formatClass: aClass	"formats an arbitrary AST"	aClass selectorsDo: [ :selector | self formatMethod: selector inClass: aClass. self n. self n].	^stream contents.! !!PrintASTAsSmalltalk methodsFor: 'initialization' stamp: 'DanteCamarena 9/25/2015 06:19'!initialize	stream:=WriteStream on: String new.	tabs:=0.! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:19'!visitSelectorNode: aSelectorNode	stream nextPutAll: aSelectorNode key! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:19'!visitLiteralNode: aLiteralNode	stream nextPutAll: aLiteralNode key printString.! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 07:38'!visitInstanceVariableNode: anInstanceVariableNode	stream nextPutAll: anInstanceVariableNode name.	^self! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:19'!visitVariableNode: aVariableNode	stream nextPutAll: aVariableNode name.	^self! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:29'!visitAssignmentNode: anAssignmentNode	"N.B.  since assigment happens after the value is evaluated the value is visited first."			anAssignmentNode variable accept: self.	stream nextPutAll: ' := '.	anAssignmentNode value accept: self.! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:32'!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	self s.	aMessageNode selector accept: self.	self s.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self.self s.].! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:19'!visitLiteralVariableNode: aLiteralVariableNode	stream nextPutAll: aLiteralVariableNode name! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:31'!visitBlockNode: aBlockNode	stream nextPutAll: '['.	aBlockNode arguments do: [:arg | arg accept:self. self s].	stream nextPutAll: ' | '.	self visitStatements: aBlockNode block statements.	stream nextPutAll: ']'.	^self! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:19'!visitTempVariableNode: aTempVariableNode	stream nextPutAll: aTempVariableNode name.	^self! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 07:30'!visitStatements:stmts		stmts do: [:arg | arg accept:self.stream nextPutAll:'.'. self n. ].! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 06:44'!visitReturnNode: aReturnNode	stream nextPutAll: '^'.	aReturnNode expr accept: self! !!PrintASTAsSmalltalk methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 07:29'!visitMethodNode: aMethodNode	|selectors args|	selectors := aMethodNode selector splitOn: ':'.	selectors remove:'' ifAbsent:[].	args := (aMethodNode arguments).	args size > 0 ifTrue:[1 to: selectors size do: [:i | 		stream nextPutAll: (selectors at:i).		stream nextPutAll: ':'.		(args at: i) accept:self.		self s]] ifFalse:[			stream nextPutAll: aMethodNode selector.	].	self nt.	aMethodNode temporaries  size > 0 ifTrue: [	stream nextPutAll:'| '.		aMethodNode temporaries do: [:arg | arg accept:self. self s].	stream nextPutAll:'| ' .	self n.	].		self visitStatements: aMethodNode block statements.	tabs := tabs -1.	^self.! !ParseNodeVisitor subclass: #PrintASTAsLisp	instanceVariableNames: 'stream temps tabs'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assignment1'!!PrintASTAsLisp commentStamp: 'DanteCamarena 9/25/2015 06:14' prior: 0!Prints ASTs as Lisp for several different situations, using the visitor pattern.The PrintASTAsLisp is a visitor class that implements methods to visit the different types of nodes found within an abstract syntax tree. A visitor object is supplied as an argument to the accept method found on these various nodes, and each node will then call the approapriate method on the visitor object, passing itself as an argument. This allows each node to be handled differently in a flexible way while iterating over nodes in the tree.To use this class, simply instantiate an object, and then call the accept method found on any given node that implements the visitor pattern. Be sure to subclass this class in case that you wish to override or add more methods to handle more nodes.!!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 02:30'!visitSelectorNode: aSelectorNode	stream nextPutAll: aSelectorNode key! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 02:01'!visitLiteralNode: aLiteralNode	stream nextPutAll: aLiteralNode key printString.! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 07:39'!visitInstanceVariableNode: anInstanceVariableNode	stream nextPutAll: anInstanceVariableNode name.	^self! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 05:49'!visitVariableNode: aVariableNode	stream nextPutAll: aVariableNode name.	^self! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 05:13'!visitAssignmentNode: anAssignmentNode	"N.B.  since assigment happens after the value is evaluated the value is visited first."		stream nextPutAll: '(setq '.	anAssignmentNode variable accept: self.	self s.	anAssignmentNode value accept: self.	stream nextPutAll: ')'.! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 02:21'!visitMessageNode: aMessageNode	stream nextPutAll: '('.	aMessageNode selector accept: self.	self s.	aMessageNode receiver accept: self.	self s.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self.self s.].	stream nextPutAll: ')'.! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 02:33'!visitLiteralVariableNode: aLiteralVariableNode	stream nextPutAll: aLiteralVariableNode name! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 05:27'!visitBlockNode: aBlockNode	stream nextPutAll: '(lambda ( '.	aBlockNode arguments do: [:arg | arg accept:self. self s].	stream nextPutAll: ') '.	self visitStatements: aBlockNode block statements.	stream nextPutAll: ')'.	^self! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 02:02'!visitTempVariableNode: aTempVariableNode	stream nextPutAll: aTempVariableNode name.	^self! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 05:28'!visitStatements:stmts stmts size >1 	ifTrue: [		self nt.		stream nextPutAll:'(progn'.		self nt.		stmts do: [:arg | arg accept:self. self n].		stream nextPutAll: ')'.		tabs := tabs - 2 .]	ifFalse: [		stmts do: [:arg | arg accept:self. ]	].! !!PrintASTAsLisp methodsFor: 'visiting' stamp: 'DanteCamarena 9/25/2015 05:30'!visitMethodNode: aMethodNode	stream nextPutAll: '(defun '.	stream nextPutAll: aMethodNode selector.	stream nextPutAll: ' ( '.	aMethodNode arguments do: [:arg | arg accept:self. self s].	stream nextPutAll: ') '.	self visitStatements: aMethodNode block statements.	stream nextPutAll: ')'.	^self.! !!PrintASTAsLisp methodsFor: 'initialization' stamp: 'ZackHarris 12/16/2015 17:16'!visitPELProgramNode: aProgramNode	aProgramNode declarations		do: [ :e | self visitInstanceVariableNode: e  ].	aProgramNode methods do: [ :e | e accept: self ].! !!PrintASTAsLisp methodsFor: 'initialization' stamp: 'DanteCamarena 9/25/2015 05:07'!initialize	stream:=WriteStream on: String new.	tabs:=0.! !!PrintASTAsLisp methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 01:40'!nt	tabs := tabs+1. stream crtab:tabs.! !!PrintASTAsLisp methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 01:40'!n	stream crtab:tabs.! !!PrintASTAsLisp methodsFor: 'util' stamp: 'DanteCamarena 9/25/2015 02:04'!s	stream space.! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 05:07'!format:ast	ast accept: self.	^stream contents.	! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 11/11/2015 07:58'!formatAST: ast instanceVarNodes: vars	"formats an arbitrary AST"	| classFactory cl |	classFactory := ClassFactoryForTestCase new. 	cl := classFactory newSubclassOf: Object instanceVariableNames: (vars map:[:a| a assignment variable  name]) classVariableNames: ''. 	cl class compile: 'initialize 		^self'.	^self formatAST: ast inClass:cl! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 05:03'!formatMethod: method inClass: cl	"formats an arbitrary AST"	| str |	str := (cl methodDict at: method) sourceCode.	^self formatString: str inClass:cl.! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'ZackHarris 12/16/2015 17:15'!formatProg:prog	"formats an arbitrary AST"	| classFactory cl |"	classFactory := ClassFactoryForTestCase new. 	cl := classFactory newSubclassOf: Object instanceVariableNames: (Character space join:(prog declarations collect:[:a| a assignment variable  name])) classVariableNames: ''. 	cl class compile: 'initialize 		^self'.	prog methods do: [:a|a accept: self]."	prog accept:self.	^ stream contents.	! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 11/11/2015 07:59'!formatAST:ast inClass:klass	^self format: (Parser new parse: ast class:klass).! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 04:52'!formatString:str	^self formatString:str inClass:Object.! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 04:51'!formatString:str inClass:klass	^self format: (Parser new parse: str class:klass).! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 04:56'!formatString: str instanceVariables: vars	"formats an arbitrary AST"	| classFactory cl |	classFactory := ClassFactoryForTestCase new. 	cl := classFactory newSubclassOf: Object instanceVariableNames: vars classVariableNames: ''. 	cl class compile: 'initialize 		^self'.	^self formatString: str inClass:cl! !!PrintASTAsLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 05:20'!formatClass: aClass	"formats an arbitrary AST"	aClass selectorsDo: [ :selector | self formatMethod: selector inClass: aClass. self n. self n].	^stream contents.! !TestCase subclass: #SmallTalkTest	instanceVariableNames: 'emptyMethod argumentMethod multiArgumentMethod complexMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assignment1'!!SmallTalkTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 07:07'!setUpemptyMethod:= Parser new parse: 'foo' class: Object.argumentMethod:= Parser new parse:'foo:x ^x' class: Object.multiArgumentMethod := Parser new parse:'foo: x with: y ^x+y' class: Object.complexMethod:= Parser new parse:'		foo: x with: y		|a b c| 		a:=5.		b:=a*(b+x).		c:=y.		Transcript show: ''asd''.		^x+y'	class: Object.! !!SmallTalkTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 07:26'!testComplexMethod| temp nv |nv := PrintASTAsSmalltalk new.temp :=(nv format: complexMethod).self assert: temp = 'foo:x with:y 	| a b c | 	a := 5	b := a * b + x  	c := y	Transcript show: ''asd'' 	^x + y 	'.! !!SmallTalkTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 07:24'!testMethod| nv test|nv := PrintASTAsSmalltalk new.test:=(nv format: emptyMethod).self assert: test = 'foo	^self	'.! !!SmallTalkTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 07:26'!testMultiArgumentMethod| temp nv |nv := PrintASTAsSmalltalk new.temp :=(nv format: multiArgumentMethod ).self assert: temp = 'foo:x with:y 	^x + y 	'.! !!SmallTalkTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 07:25'!testArgumentMethod| temp nv |nv := PrintASTAsSmalltalk new.temp :=(nv format: argumentMethod ).self assert: temp = 'foo:	^x	'.! !TestCase subclass: #LispTest	instanceVariableNames: 'emptyMethod argumentMethod multiArgumentMethod complexMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assignment1'!!LispTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 11/10/2015 07:01'!setUpemptyMethod:= Parser new parse: 'foo' class: Object.argumentMethod:= Parser new parse:'foo:x ^x' class: Object.multiArgumentMethod := Parser new parse:'foo: x with: y ^x+y' class: Object.complexMethod:= Parser new parse:'		foo: x with: y		|a b c| 		a:=5.		b:=a*(b+x).		 c:=y.		Transcript show: ''asd''.		a.		1 to: 20 by: 2 do: [ :xx | xx printN1 ].		^x+y'	class: Object.! !!LispTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 06:12'!testComplexMethod| temp nv |nv := PrintASTAsLisp new.temp :=(nv format: complexMethod).self assert: temp = '(defun foo:with: ( x y ) 	(progn		(setq a 5)		(setq b (* a (+ b x ) ))		(setq c y)		(show: Transcript ''asd'' )		(+ x y )		))'.! !!LispTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 06:16'!testMethod| nv test|nv := PrintASTAsLisp new.test:=(nv format: emptyMethod).self assert: test = '(defun foo ( ) self)'.! !!LispTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 06:12'!testMultiArgumentMethod| temp nv |nv := PrintASTAsLisp new.temp :=(nv format: multiArgumentMethod ).self assert: temp = '(defun foo:with: ( x y ) (+ x y ))'.! !!LispTest methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 06:12'!testArgumentMethod| temp nv |nv := PrintASTAsLisp new.temp :=(nv format: argumentMethod ).self assert: temp = '(defun foo: ( x ) x)'.! !Object subclass: #ScopeEnvironment	instanceVariableNames: 'ZackStack topScope currentScope'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign3'!!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 08:31'!getSymbolRaw: symbol	| res iterator|	res := currentScope lookupVar: symbol.	(res isTemp and: [res scope outerNotOptimizedScope ~= currentScope outerNotOptimizedScope] ) 		ifTrue: [			iterator := currentScope.			iterator addCopyingTemp: res.			[			iterator:= iterator outerScope .				iterator addCopyingTemp: res.			res scope outerNotOptimizedScope ~= iterator outerNotOptimizedScope]whileTrue:[											].		].	^ res! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 04:44'!initialize	|classScope|	classScope := OCClassScope new class: CompilationClass.	topScope:= OCInstanceScope new.		classScope addChild: topScope .	topScope outerScope: classScope.	currentScope := topScope.	super initialize! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 15:53'!createBlockScope:aBlockNode|s|	s :=OCBlockScope new.	s outerScope: currentScope.	s node:aBlockNode.	aBlockNode scope: s.	currentScope addChild: s.	currentScope := s.! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:30'!currentScope^currentScope.! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:06'!addSymbol: typedVar(typedVar isKindOf: MethodNode)ifTrue:[	"\_(ツ)_/¯"	]ifFalse:[	 (currentScope isKindOf: OCAbstractMethodScope ) ifFalse:[Error signal:'NOOOO'].		currentScope addTemp: typedVar name.	]!]lang[(210)0! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 15:52'!createMethodScope:aMethodNode	|s|	s :=OCMethodScope new.	s node: aMethodNode.	aMethodNode scope: s.	currentScope addChild: s.	s outerScope: currentScope.	currentScope := s.! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 18:36'!destroyScope	currentScope := currentScope outerScope.! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 05:35'!getInstVarIndex:symbol	^topScope getSlotNum: symbol.! !!ScopeEnvironment methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 04:46'!progInit:progNode	|slots| 	slots := progNode declarations collect:[:a|a variable].	topScope slots:slots.	topScope node: progNode.	topScope outerScope node: progNode.! !ParseNodeVisitor subclass: #SemanticAnalyzer	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign3'!!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 14:56'!visitLiteralNode: aTypedLiteralNode	^ aTypedLiteralNode type.! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 16:23'!visitInstanceVariableNode: aDefinitionNode	env addSymbol: aDefinitionNode variable.	self visitAssignmentNode: aDefinitionNode assignment.! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 23:30'!analyze:aPELProgram	|ast|	ast := PELParser new parse: aPELProgram.	self visitPELProgramNode: ast.	^ast! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 18:54'!visitVariableNode: aVariableNode|v|	v:=(env findVarSymbol: aVariableNode name).	^v type.! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 10:33'!visitAssignmentNode: anAssignmentNode	| leftHandType rightHandType res |	rightHandType := anAssignmentNode value accept: self.	leftHandType := anAssignmentNode variable accept: self.	res := leftHandType unify: rightHandType.	res = #derp		ifTrue: [ 			anAssignmentNode				variable: anAssignmentNode variable				value:					(TypedMessageNode new						receiver:							(VariableNode new								name: #self								key: #self								index: nil								type: 3)						selector: (SelectorNode new key: #fill:with:)						arguments:							{leftHandType dimensions at:1.							(anAssignmentNode value)}						precedence: 3) ]		ifFalse: [ 			res				ifTrue: [ leftHandType ]				ifFalse: [ Error signal: 'Cannot assign given type to variable ' , anAssignmentNode variable name ] ]! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 16:23'!initialize	env := Environment new.! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/21/2015 14:19'!visitMessageNode: aMessageNode	| typedMethodNode messageArgs methodArgs recType argTypes |	^ aMessageNode selector= #value		ifTrue: [ aMessageNode receiver accept: self ]		ifFalse: [ 			aMessageNode selector = #at:				ifTrue: [ 					| arrType |					arrType := aMessageNode receiver accept: self.					(arrType isKindOf: ArrayTypeNode)						ifFalse: [ Error signal: 'Tried to index non-Array: ' , aMessageNode receiver name ].					arrType innerType ]				ifFalse: [ 					aMessageNode selector = #at:put:						ifTrue: [ 							| arrType elem |							arrType := aMessageNode receiver accept: self.							(arrType isKindOf: ArrayTypeNode)								ifFalse: [ Error signal: 'Tried to index non-Array: ' , aMessageNode receiver name ].							elem := aMessageNode arguments at: 2.	"				(i>0 and: i<=(arrType dimensions at:1)) ifFalse:[Error signal: 'Out of bounds on: ' , aMessageNode receiver name]."							arrType innerType unify: elem ]						ifFalse: [ 							aMessageNode selector = #doWithIndex:								ifTrue: [ 									| block vn arrType|									arrType := aMessageNode receiver accept: self.									(arrType isKindOf: ArrayTypeNode)										ifFalse: [ Error signal: 'Tried to index non-Array: ' , aMessageNode receiver name ].									block := aMessageNode arguments at: 1.									vn := block arguments at: 1.									block arguments: {(TypedVariableNode fromNode: vn typeStr: arrType innerType). (TypedVariableNode fromNode: (block arguments at: 2) typeStr: 'int')}.									block accept: self.									TypeNode new name: 'void' length: 0 ]								ifFalse: [ 									recType := aMessageNode receiver accept: self.									argTypes := aMessageNode arguments collect: [ :a | a accept: self ].									typedMethodNode := env										findMethodSymbol: aMessageNode selector asString										receiverType: recType										argTypes: argTypes.									messageArgs := aMessageNode arguments.									methodArgs := typedMethodNode arguments.									methodArgs size = messageArgs size										ifFalse: [ Error signal: 'Argument quantity mismatch on function call:' , typedMethodNode name ]										ifTrue: [ 											1 to: methodArgs size do: [ :i | 												| currentMsgArgType currentMethArgType |												currentMsgArgType := (messageArgs at: i) accept: self.												currentMethArgType := (methodArgs at: i) type.												(currentMethArgType unify: currentMsgArgType)													ifFalse: [ Error signal: 'Type Mismatch cannot assign: ' , currentMethArgType name , ' from ' , currentMsgArgType name ] ] ].									typedMethodNode type ] ] ] ]! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 16:57'!visitPELProgramNode: aProgramNode	env createScope.	self initializeLibrary.		aProgramNode declarations		do: [ :e | self visitInstanceVariableNode: e  ].	aProgramNode methods do: [ :e | env addSymbol: e ].	aProgramNode methods do: [ :e | e accept: self ].	env destroyScope.	^ self! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 09:39'!visitBlockNode: aBlockNode	| res r2 |	r2:=(TypeNode new name:'void'length:0).	env createScope.	aBlockNode arguments do:[:e|env addSymbol: e].	aBlockNode temporaries do:[:e|env addSymbol: e].	aBlockNode statements do: [ :statement | ((statement isKindOf: VariableNode) and:[statement key = 'nil'])ifTrue:[^r2]. res := statement accept: self. (statement isKindOf: ReturnNode) ifTrue:[r2:=res] ].	env destroyScope.	^ r2! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 22:58'!initializeLibrary| printMethod printAsMethod toByDoMethod sqrtMethod|printMethod := TypedMethodNode new type: 'void' name: 'print:' argumentTypes: { 'format' } receiverType: 'god'.printAsMethod := TypedMethodNode new type: 'void' name: 'print:as:' argumentTypes: { 'object'.'format' } receiverType: 'god'.	toByDoMethod := TypedMethodNode new type: 'void' name: 'to:by:do:' argumentTypes: { 'int'.'int'.'void' } receiverType: 'int'.	sqrtMethod := TypedMethodNode new type: 'real' name: 'sqrt:' argumentTypes: { 'int' } receiverType: 'god'.env addSymbol: (TypedVariableNode new name:'self' type: (TypeNode new name:'god' length:0)).env addSymbol: printMethod.env addSymbol: printAsMethod.env addSymbol: toByDoMethod.env addSymbol: sqrtMethod.env addSymbol: (TypedMethodNode new type: 'int' name: '+' argumentTypes: { 'int' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '+' argumentTypes: { 'real' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '+' argumentTypes: { 'real' } receiverType: 'real').env addSymbol: (TypedMethodNode new type: 'int' name: '-' argumentTypes: { 'int' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '-' argumentTypes: { 'real' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '-' argumentTypes: { 'real' } receiverType: 'real').env addSymbol: (TypedMethodNode new type: 'int' name: '*' argumentTypes: { 'int' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '*' argumentTypes: { 'real' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '*' argumentTypes: { 'real' } receiverType: 'real').env addSymbol: (TypedMethodNode new type: 'int' name: '/' argumentTypes: { 'int' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '/' argumentTypes: { 'real' } receiverType: 'int').env addSymbol: (TypedMethodNode new type: 'real' name: '/' argumentTypes: { 'real' } receiverType: 'real').! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 01:41'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!SemanticAnalyzer methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/17/2015 01:30'!visitMethodNode: aMethodNode	|lhs rhs res|	env createScope.	aMethodNode temporaries do:[:e|env addSymbol: e].	rhs:=(aMethodNode block accept: self).	lhs:= aMethodNode type.	res:= lhs unify: rhs.	res ifFalse:[Error signal: ' Non-Matching return type on method: ', aMethodNode name].	env destroyScope.	^self.! !Error subclass: #MethodNotFoundException	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign3'!Object subclass: #Environment	instanceVariableNames: 'ZackStack'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign3'!!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 21:16'!findMethodSymbol: symbol receiverType: recType argTypes: argTypes	| res res2 |	res := self getSymbolRaw: symbol.	res isNil ifTrue: [MethodNotFoundException signal:': ', symbol].	res2 := res		detect: [ :a | 			| argMatch |			argMatch := a receiverType unify: recType.			argMatch := argMatch and: a arguments size = argTypes size.			argMatch				ifTrue: [ 1 to: argTypes size do: [ :i | argMatch := argMatch and: ((a arguments at: i) type unify: (argTypes at: i)) ] ].							argMatch ]				ifFound: [ :a | a]		ifNone: [ Error signal: 'Symbol not Found:' , symbol ].	^ res2! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 18:23'!getSymbolRaw: symbol	| res |	res := ZackStack detect: [ :a | a includesKey: symbol ] ifFound: [ :a | a at: symbol ] ifNone: [ nil ].	^ res! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 15:07'!initialize	ZackStack := Stack new.	super initialize! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/13/2015 16:18'!checkScope:symbol	^ ZackStack top includesKey: symbol.! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 20:38'!findVarSymbol: symbol	| res |	res := self getSymbolRaw: symbol.	res isNil ifTrue: [Error signal:'Variable not found: ', symbol].	(res isKindOf:VariableNode ) ifFalse: [Error signal:'Expected variable, not ', symbol].	^ res! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/15/2015 20:53'!addSymbol: typedVar	| n res |	n := typedVar name.	res := ZackStack top includesKey: n.	(res isKindOf: VariableNode)		ifTrue: [ Error signal: 'Identifier is already in Scope: ' , n ].	res ifFalse: [ 			(typedVar isKindOf: VariableNode)				ifTrue: [ ZackStack top at: n put: typedVar ]				ifFalse: [ ZackStack top at: n put: {typedVar} asOrderedCollection ] ].	(res isKindOf: OrderedCollection)		ifTrue: [ 			(typedVar isKindOf: TypedMethodNode)				ifTrue: [ 					[ 					self						findMethodSymbol: typedVar name						receiverType: typedVar receiverType						argTypes: (typedVar arguments collect: [ :a | a type ]).					Error signal: 'Identifier is already in Scope' , n ]						on: MethodNotFoundException						do: [ (ZackStack top at: n) add: typedVar ] ]				ifFalse: [ Error signal: 'Identifier is already in Scope' , n ] ]! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 15:08'!destroyScope	ZackStack pop.! !!Environment methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/12/2015 15:08'!createScope	ZackStack push: Dictionary new.! !ParseNodeVisitor subclass: #Scoper	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign3'!!Scoper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:22'!initialize	env := ScopeEnvironment new.! !!Scoper methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 13:25'!visitBlockNode: aBlockNode	env createBlockScope: aBlockNode.		aBlockNode arguments do:[:e|env addSymbol: e].	aBlockNode temporaries do:[:e|env addSymbol: e].		aBlockNode statements do: [ :statement | ((statement isKindOf: VariableNode) and:[statement key = 'nil'])ifFalse:[statement accept: self] ].	env destroyScope.! !!Scoper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:26'!visitPELProgramNode: aProgramNode"	aProgramNode declarations		do: [ :e | self visitInstanceVariableNode: e  ]. TODO: Make initialize Method."	aProgramNode methods do: [ :e | e accept: self ].! !!Scoper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:48'!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	aMessageNode arguments do: [ :a | a accept: self ].! !!Scoper methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 19:23'!analyze:aPELProgramNode	env progInit: aPELProgramNode.	self visitPELProgramNode: aPELProgramNode.! !!Scoper methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/20/2015 05:08'!visitVariableNode: aVariableNode |res|res := env getSymbolRaw: aVariableNode name.(res isKindOf:OCSlotVariable) ifTrue:[aVariableNode setIndex: (env getInstVarIndex: aVariableNode name)]ifFalse:[aVariableNode setIndex: 0].^res! !!Scoper methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 13:25'!visitMethodNode: aMethodNode 	env createMethodScope: aMethodNode.	"Args handled by block, May need to be Copied or something"			aMethodNode arguments do:[:e|env addSymbol: e].	aMethodNode block temporaries do:[:e|env addSymbol: e].	aMethodNode temporaries do:[:e|env addSymbol: e].		aMethodNode block statements do: [ :statement | ((statement isKindOf: VariableNode) and:[statement key = 'nil'])ifFalse:[statement accept: self]].	env destroyScope.	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Scoper class	instanceVariableNames: 'debug'!!Scoper class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 12:25'!debug^debug.! !!Scoper class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 12:25'!debugResetdebug:= 0.! !!Scoper class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 12:24'!debugInc	debug := debug + 1.! !CompilationClass subclass: #PELClass1	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!CompilationClass subclass: #PELClass3	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!CompilationClass subclass: #PELClass4	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!CompilationClass subclass: #PELClass6	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!CompilationClass subclass: #PELClass5	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!CompilationClass subclass: #PELClass2	instanceVariableNames: 'n'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Test'!Object subclass: #ZLisp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-preMerge'!!ZLisp commentStamp: 'ZackHarris 9/24/2015 20:00' prior: 0!Prints ASTs as Lisp for several different situations, using the visitor pattern.!!ZLisp methodsFor: 'formatting' stamp: 'DanteCamarena 9/25/2015 06:11'!format: ast	"formats an arbitrary AST"	| visitor |	visitor := (ZNodeVisitor new).	^ast accept: visitor.! !!ZLisp methodsFor: 'formatting' stamp: 'ZackHarris 9/24/2015 20:07'!formatString: str	"formats an arbitrary AST"	| ast  |	ast := Parser new parse: str class: Object.	^self format: ast.! !!ZLisp methodsFor: 'formatting' stamp: 'ZackHarris 9/24/2015 20:45'!formatMethod: method inClass: cl	"formats an arbitrary AST"	| ast str |	str := (cl methodDict at: method) sourceCode.	ast := Parser new parse: str class: cl.	^self format: ast.! !!ZLisp methodsFor: 'formatting' stamp: 'ZackHarris 9/24/2015 20:09'!formatString: str inClass: klass	"formats an arbitrary AST"	| ast |	ast := Parser new parse: str class: klass.	^self format: ast.! !!ZLisp methodsFor: 'formatting' stamp: 'ZackHarris 9/24/2015 20:42'!formatString: str instanceVariables: vars	"formats an arbitrary AST"	| ast classFactory cl |	classFactory := ClassFactoryForTestCase new. 	cl := classFactory newSubclassOf: Object instanceVariableNames: vars classVariableNames: ''. 	cl class compile: 'initialize 		^self'.		ast := Parser new parse: str class: cl.	^self format: ast.! !!ZLisp methodsFor: 'formatting' stamp: 'ZackHarris 9/25/2015 01:06'!formatClass: aClass	"formats an arbitrary AST"	| str |	str := ''.	aClass selectorsDo: [ :selector | str := str , (self formatMethod: selector inClass: aClass), '		' ].	^str.! !TestCase subclass: #ZASTTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-preMerge'!!ZASTTests methodsFor: 'as yet unclassified' stamp: 'ZackHarris 9/25/2015 00:27'!setUp	"comment stating purpose of message"! !!ZASTTests methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 9/25/2015 06:11'!testFormat	"comment stating purpose of message"	| str |	str := ZLisp new formatClass: ZNodeVisitor."	self assert"! !ParseNodeVisitor subclass: #ZNodeVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-preMerge'!!ZNodeVisitor commentStamp: 'ZackHarris 9/24/2015 02:50' prior: 0!The ASTNodeVisitor is a visitor class that implements methods to visit the different types of nodes found within an abstract syntax tree. A visitor object is supplied as an argument to the accept method found on these various nodes, and each node will then call the approapriate method on the visitor object, passing itself as an argument. This allows each node to be handled differently in a flexible way while iterating over nodes in the tree.To use this class, simply instantiate an object, and then call the accept method found on any given node that implements the visitor pattern. Be sure to subclass this class in case that you wish to override or add more methods to handle more nodes.!!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 02:23'!visitSelectorNode: aSelectorNode	"comment stating purpose of message"	^aSelectorNode key! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/25/2015 02:00'!visitLiteralNode: aLiteralNode	"comment stating purpose of message"	^aLiteralNode key asString.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 01:47'!visitVariableNode: aVariableNode	"comment stating purpose of message"	^aVariableNode name! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/25/2015 00:50'!visitAssignmentNode: anAssignmentNode	"comment stating purpose of message"	^'(setq ' , (anAssignmentNode variable accept: self) , ' ' , (anAssignmentNode value accept: self) , ')'.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/25/2015 03:21'!visitMessageNode: aMessageNode	"comment stating purpose of message"	| str |	str := '(',  (aMessageNode selector accept: self) , ' ', (aMessageNode receiver accept: self).	aMessageNode arguments do: [ :i | i ifNotNil: [str := str , ' ', (i accept: self)] ].	str := str, ')'.	^str.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 23:17'!visitCommentNode: anCommentNode	"comment stating purpose of message"	^''.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 03:14'!visitBlockNode: aBlockNode	"comment stating purpose of message"	| str |	str := ''.	aBlockNode statements do: [ :i | str := str , (i accept: self)].	^str.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/25/2015 01:51'!visitLiteralVariableNode: aLiteralVariableNode	"comment stating purpose of message"	^aLiteralVariableNode name! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 01:56'!visitTempVariableNode: aVariableNode	"comment stating purpose of message"	^aVariableNode name! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 02:17'!visitReturnNode: aReturnNode	"comment stating purpose of message"	| str |	str := '(return ',  (aReturnNode expr accept: self) , ')'.	^str.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/25/2015 03:18'!visitCascadeNode: aCascadeNode	"comment stating purpose of message"	| str |	str := ''.	aCascadeNode messages do: [ :msg | msg receiver: aCascadeNode receiver. str := str , (msg accept: self)].	^str.! !!ZNodeVisitor methodsFor: 'visiting' stamp: 'ZackHarris 9/24/2015 20:57'!visitMethodNode: aMethodNode	"comment stating purpose of message"	| str |	str := '(method ', (aMethodNode selector), ' ('.	str:= str , (Character space join: (aMethodNode arguments collect: [ :i | i accept: self ])).	str := str , ') '.	str := str , (aMethodNode body accept: self), ')'.	^str.! !Object subclass: #Examples	instanceVariableNames: 'methodNode'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign4'!!Examples methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 21:26'!print: pTranscript show: p.! !!Examples methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/16/2015 21:32'!main|m|m:=4.self print: m! !PPCompositeParser subclass: #FSParser	instanceVariableNames: 'string formatChar'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign4'!!FSParser methodsFor: 'grammar' stamp: 'ZackHarris 12/19/2015 23:35'!formatChar	^ $~ asParser / $@ asParser / $# asParser / $. asParser / $* asParser / $+ asParser! !!FSParser methodsFor: 'grammar' stamp: 'ZackHarris 12/19/2015 23:35'!string	| doublequote |	doublequote := $" asParser.	^ (doublequote , ('""' asParser / doublequote negate) star flatten , doublequote) ==> [ :s | s at: 2 ]! !!FSParser methodsFor: 'grammar' stamp: 'ZackHarris 12/19/2015 23:39'!start	"| strOrNum formatPieces x y  |	strOrNum := string.	formatPieces := (formatChar / string) star.	x := (strOrNum optional , formatChar , formatPieces)		==> [ :a | 			(a at: 1) isNil				ifTrue: [ {(a at: 2)} , (a at: 3) ]				ifFalse: [ {(a at: 1)} , {(a at: 2)} , (a at: 3) ] ].	y := (strOrNum , strOrNum , formatPieces) ==> [ :a | {(a at: 1)} , {(a at: 2)} , (a at: 3) ].	^(x / y) ==> [ :a | FormatSpecifier new init: a ]."|formatChars strFirst specifier|formatChars := formatChar plus.strFirst := string , formatChars." ==> [:a | {(a at: 1)} , (a at:2)]."specifier := (strFirst / (formatChars==>[:a|{a}])) , (string / formatChars) star.^specifier ==> [ :a | FormatSpecifier new init: (a at: 1),(a at: 2)].! !Object subclass: #IRPrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign4'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IRPrinter class	instanceVariableNames: ''!!IRPrinter class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 09:30'!code2^'proc main	print ~"awas"corp'.! !!IRPrinter class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/21/2015 09:54'!PrintIR| ib ir sem ps ot|ps := WriteStream on: String new.sem := SemanticAnalyzer new analyze: self code.Scoper new analyze: sem.sem methods do:[:m|ot:= OCASTTranslator new. ib:=ot visitNode: m.ir := ib ir.sem compilationClass addSelectorSilently: m selector withMethod: ir compiledMethod.ir longPrintOn: ps.].^ps contents.! !!IRPrinter class methodsFor: 'as yet unclassified' stamp: 'DanteCamarena 12/19/2015 21:45'!code^'proc main  int m := 4  print "    |"  for i from 0 to m do print "      |" od  print ~"----+"  for i from 0 to m do print "-------+" od  print ~  for i from 1 to n do    printrow(i,m)  odcorpint n := 10proc printrow(int x,int y)  print x as " "##" |"  int sum := 0  int array[y] z := genpowers(x,y,sum)  print sqrt(x) as " "#.###" |"  for z do print z[index] as " "#####" |" od   print sum as " = "*#~corpint array proc genpowers(int x,int n,mutable int sum)  int array[n] result := 0  int accum := 1  for i from 1 to n do    accum := accum * x    result[i] := accum    sum := sum + accum  od  return resultcorp'.! !Object subclass: #CompilationClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CPS710-Assign4'!!CompilationClass methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/21/2015 14:03'!fill:x with:y^(1 to: x) collect:[:a|y].! !!CompilationClass methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/20/2015 06:59'!print: obj as: format	| parser output stream |	parser := FSParser new.	output := parser parse: format.	(output isKindOf: FormatSpecifier)		ifFalse: [ Error signal: 'Error: The method print:as: did not receive a FormatSpecifier as its second argument.' ].	stream := WriteStream on: String new.	(obj isKindOf: Number)	ifTrue: [ 		output me		do: [ :elem | 			(elem isKindOf: ByteString)				ifTrue: [ 					"elem printOn: stream "					stream nextPutAll: elem.					]				ifFalse: [ 					| numformat foundDot foundStar printedFormat errMsg |					numformat := ''.				   foundDot := false. foundStar := false.					printedFormat := false.					errMsg := 'Error: Cannot represent two or more symbols in format specifier.'.					elem						do: [ :formatChar | 							formatChar = $@								ifTrue: [ Error signal: 'Error: The print:as: method cannot use the @ symbol to format numbers.' ].							formatChar = $*								ifTrue: [ printedFormat ifTrue: [ Error signal: errMsg ].									(foundStar = true) ifTrue:[ Error signal: 'Error: Found two or more stars in the format specifier.' ]. 									(numformat size = 0) ifFalse: [ Error signal: 'Error: The star must come before the hash symbol.' ].									numformat := numformat , formatChar asString. foundStar := true.].							formatChar = $~								ifTrue: [									(numformat size = 0) ifFalse: [ self printNumber: obj format: numformat stream: stream. 										numformat:=''. printedFormat:=true. ].									stream cr ].							formatChar = $#								ifTrue: [ printedFormat ifTrue: [ Error signal: errMsg ].									numformat := numformat , formatChar asString. ].							formatChar = $.								ifTrue: [ printedFormat ifTrue: [ Error signal: errMsg ].									(foundDot = true) ifTrue:[ Error signal: 'Error: Found two or more dots in the format specifier.' ]. 									numformat := numformat , formatChar asString. foundDot := true. ].								 ].							((numformat size = 0) or: [ printedFormat ]) ifFalse: [ self printNumber: obj format: numformat stream: stream. ].						] ].	] ifFalse: [ 	(obj isKindOf: String) ifFalse: [ Error signal: 'Error: First argument of print:as: had the incorrect type.' ].		output me		do: [ :elem | 			| count foundAt |			count:=0.			foundAt := false.			(elem isKindOf: ByteString)				ifTrue: [ elem printOn: stream ]				ifFalse: [ 					elem						do: [ :formatChar | 							formatChar = $#								ifTrue: [ Error signal: 'Error: The print:as: method cannot use the # symbol to format numbers.' ].							formatChar = $.								ifTrue: [ Error signal: 'Error: The print:as: method cannot use the . symbol to format numbers.' ].							formatChar = $~								ifTrue: [ stream cr ].							formatChar = $@								ifTrue: [ 									foundAt ifFalse: [ 										foundAt := true.										stream nextPutAll: obj.										"obj printOn: stream."									]								].															 ] ] ].	].		Transcript show: stream contents! !!CompilationClass methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/20/2015 07:05'!sqrt: x^x sqrt! !!CompilationClass methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/20/2015 00:28'!print:str|parser output stream|parser:=FSParser new.output := parser parse: str.(output isKindOf: FormatSpecifier)ifTrue: [	"format specifier case"	stream := WriteStream on: String new.	output me do: [ :elem |		(elem isKindOf: ByteString) 		ifTrue: [ 			elem printOn: stream.		] ifFalse: [ 			elem do: [ :formatChar |				(formatChar = $~) 				ifTrue: [ stream cr ]				ifFalse: [ Error signal: 'Invalid format character used in format specifier. (Did you mean to use print:as:?)' ]			]		]	].	Transcript show: stream contents.] ifFalse: [	"string case"	^Transcript show: str.]! !!CompilationClass methodsFor: 'as yet unclassified' stamp: 'ZackHarris 12/20/2015 06:56'!printNumber: aNumber format: aFormat stream: aStream|leftFormat rightFormat leftNum rightNum dotIndex strSize numStr formatNum tempStr tempNum|leftFormat:=0.rightFormat:=0.leftNum:=0.rightNum:=0.tempNum := aNumber.dotIndex:=(aFormat indexOf: $.).strSize:=aFormat size.(dotIndex = 0) ifTrue: [ leftFormat := strSize. rightFormat=0. ]ifFalse: [ leftFormat := dotIndex-1. rightFormat := strSize-dotIndex. ]."Error signal."numStr:=aNumber asString.dotIndex:=(numStr indexOf: $.).strSize:=numStr size.(dotIndex = 0) ifTrue: [ leftNum := strSize. rightNum=0. ]ifFalse: [ leftNum := dotIndex-1. rightNum := strSize-dotIndex. ].((aFormat at: 1) = $*) ifTrue: [ leftFormat := leftNum ]."formatNum := ((leftFormat asString), '.' , (rightFormat asString))"formatNum := leftFormat asString.(rightFormat = 0) ifFalse: [ formatNum := formatNum , '.' , (rightFormat asString). ].formatNum := formatNum asNumber."Error signal."(aNumber isKindOf: Integer) ifTrue: [ 	(rightFormat > 0) ifTrue: [ tempNum := aNumber asFloat ]	ifFalse: [ formatNum := formatNum asInteger ]	].tempStr := tempNum printPaddedWith: $0 to: formatNum."Error signal.""(leftFormat < leftNum) ifTrue: [ tempStr := tempStr copyFrom: (leftNum - leftFormat + 1) to: (tempStr size) ]."(rightFormat > 0 and: [rightFormat < rightNum]) ifTrue: [ tempStr := tempStr copyFrom: 1 to: (tempStr size - (rightNum - rightFormat)) ].aStream nextPutAll: tempStr."tempStr printOn: aStream."! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.32603 pm'!!SelectorNode methodsFor: '*CPS710' stamp: 'DanteCamarena 12/20/2015 08:00'!numArgs^key numArgs.! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33003 pm'!!SelectorNode methodsFor: '*CPS710' stamp: 'ZackHarris 12/16/2015 22:49'!printOn: aStream^key printOn: aStream! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33203 pm'!!OCInstanceScope methodsFor: '*CPS710' stamp: 'DanteCamarena 12/20/2015 04:55'!getSlotNum:slotName	^ vars keys indexOf:slotName! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33403 pm'!!VariableNode methodsFor: '*CPS710' stamp: 'ZackHarris 12/16/2015 20:49'!binding	^self.! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33503 pm'!!VariableNode methodsFor: '*CPS710' stamp: 'DanteCamarena 12/20/2015 05:27'!emitValue: methodBuilder	| symb |	index = 0		ifFalse: [ methodBuilder pushInstVar: index ]		ifTrue: [ 			symb := name asSymbol.			name = 'self'				ifTrue: [ methodBuilder pushReceiver ]				ifFalse: [ methodBuilder pushTemp: symb ] ]! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33603 pm'!!VariableNode methodsFor: '*CPS710' stamp: 'DanteCamarena 12/20/2015 05:00'!setIndex:iindex:=i.! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33703 pm'!!VariableNode methodsFor: '*CPS710' stamp: 'DanteCamarena 12/20/2015 05:28'!emitStore: methodBuilder	(index = 0) ifTrue:[	methodBuilder storeTemp: (name asSymbol). ]	ifFalse:[methodBuilder storeInstVar: index].! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33803 pm'!!VariableNode methodsFor: '*CPS710' stamp: 'ZackHarris 12/17/2015 00:56'!sourceInterval^0 to: 0! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.33903 pm'!!AssignmentNode methodsFor: '*CPS710' stamp: 'ZackHarris 12/17/2015 01:00'!sourceInterval^0 to: 0! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 December 2015 at 1:50:50.34003 pm'!!ParseNode methodsFor: '*CPS710' stamp: 'ZackHarris 12/16/2015 20:00'!acceptVisitor: visitor	self accept: visitor.! !